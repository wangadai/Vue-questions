# Vue 面试题

标签（空格分隔）： vue

---

### 第一题： v-if和v-for哪个优先级高？如果两个同时出现，应该怎么优化得到更好的性能？

> 当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级*（永远不要把 v-if 和 v-for 同时用在同一个元素上。）*（可写个demo输出render查看）
> 如果同时出现，每次渲染都会先执行循环，在进行判断；
> 无论如何循环都不可避免，浪费性能

- 同时出现的两种情况处理
 1. 代码：（`v-for`遍历初始数据，`v-if`根据item数据判断）
    优化：过滤一个列表中的项目，在这种情形下，将初始数据替换为一个计算属性，让其返回过滤后的列表。 
 2. 代码：（`v-for`遍历初始数据，`v-if`根据初始数据判断）
    优化：避免渲染本应该被隐藏的列表,这种情形下，请将 v-if 移动至容器元素上 。


### 第二题： Vue组件data选项为什么必须是个函数而Vue的根实例则没有此限制

> 1、vue组件中data值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其他实例也会受到影响

    var MyComponent = function() {}
    MyComponent.prototype.data = {
      a: 1,
      b: 2,
    }
    
    var component1 = new MyComponent()
    var component2 = new MyComponent()
    
    component1.data.a === component2.data.a // true
    component1.data.b = 5
    component2.data.b // 5
> 
>  2、vue组件data为函数的原因，data为函数，通过return返回对象的拷贝，致使每个实例都有自己独立的对象，实例之间可以互不影响的改变data属性值

所以确保每一个实例的`data`属性都是独立的，不会互相影响。`vue`组件里面的`data`必须是一个函数，相比`vue`的`data`，`react`的`setData`更形象

而在Vue实例创建中，只有一个，不用担心会被复用。


### 第三题： vue中key的作用和工作原理吗？说说你对它的理解

key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度
> 当使用 v-for 正在更新已渲染过的元素列表时，key的作用让每个item有一个唯一的识别身份，可以下标值index或者id, 主要是为了vue精准的追踪到每一个元素，高效的更新虚拟DOM。


### 第四题： 怎么理解vue中的diff算法

整体策略：深度优先、同层比较

 1. diff宣发是虚拟DOM技术的必然产物，通过新旧虚拟DOM对比，将变化的更新在真实DOM；（同层比较）
 2. vue 2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，只有引入diff才能精确找到发生变化的地方
 3. vue中的diff执行的时刻是组件实例执行其更新函数时，它会对比上次渲染结果和新的渲染结果，此过程称为patch
 4. diff整体遵循深度优先、同层比较的策略。比较两组子节点是算法的重点。首先假设头尾节点可能相同做4次比对尝试，如果没有找到相同节点才会按照通用方式遍历查找。查找结束在按情况处理剩下的节点；借助key通常可以精准的找到相同的节点，因为整个patch过程非常高效

### 第五题： 谈一谈对vue组件化的理解
### 第六题： 谈一谈对vue的设计原则的理解
### 第七题： vue为什么要求足见模板只能有一个根元素
### 第八题： 谈谈你对mvvm、mvp、mvc的理解
### 第九题： 谈谈你对vue组件之间通信的理解
### 第十题： 你了解哪些vue性能优化方法
### 第十一题： 你知道vue3有哪些新特性吗？以及会带来的影响
### 第十二题： vue如果想扩展某个现有的组件时应该怎么做？
### 第十三题： watch和computed的区别以及怎么选用
### 第十四题： 谈谈你对vue生命周期的理解
### 第十五题： 谈谈你对vuex使用及其理解？
### 第十六题： nextTick的原理

> 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

首先Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行异步的 DOM 的更新。
异步执行的运行机制如下： 

 1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 
 2. 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
 3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
 4. 主线程不断重复上面的第三步。

简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。

    //改变数据
    vm.message = 'changed'
    
    //想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新
    console.log(vm.$el.textContent) // 并不会得到'changed'
    
    //这样可以，nextTick里面的代码会在DOM更新后执行
    Vue.nextTick(function(){
        console.log(vm.$el.textContent) //可以得到'changed'
    })

> 应用场景：需要在视图更新之后，基于新的视图进行操作。

### 第十七题： vue的双向数据绑定的原理

> 最初的理解：Vue内部通过Object.defineProperty方法属性拦截的方式，把data对象里每个数据的读写转化成getter/setter，当数据变化时通知视图更新。

实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。
